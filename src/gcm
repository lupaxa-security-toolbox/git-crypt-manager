#!/usr/bin/env bash
# ==============================================================================
# git-crypt Manager
# ==============================================================================
# Full lifecycle management for git-crypt encrypted repositories
#
# Features:
#   • Setup git-crypt + .gitattributes rules (requires a clean repo)
#   • Add, rotate, revoke users (GPG) and auto-commit git-crypt metadata
#   • List current git-crypt collaborators from .git-crypt/keys
#   • Nuclear key rotation
#   • Remove encryption going forward (auto-commit .gitattributes)
#   • Encrypted JSON audit logs
#   • Backup & restore git-crypt configuration
#   • Simple doctor command for diagnostics
#   • CLI subcommands only (no interactive menu)
#   • Cross-platform: macOS + Linux
# ==============================================================================

set -euo pipefail

SCRIPT_NAME="gcm"
VERSION="1.0.0"

BACKUP_DIR_BASE=".git-crypt-backups"
LOG_DIR=".git-crypt-logs"

# OS-portable sed
if [[ "$OSTYPE" == "darwin"* ]]; then
    SED_CMD=(sed -i '')
else
    SED_CMD=(sed -i)
fi

# ------------------------------------------------------------------------------
# Logging helpers
# ------------------------------------------------------------------------------

init_logs_dir() {
    mkdir -p "${LOG_DIR}"
    # Ensure logs are encrypted by git-crypt (idempotent)
    if [[ -f .gitattributes ]] && ! grep -q "${LOG_DIR}/**" .gitattributes 2>/dev/null; then
        {
            echo
            echo "# Audit logs encrypted (auto-added):"
            echo "${LOG_DIR}/** filter=git-crypt diff=git-crypt"
        } >> .gitattributes || true
    fi
}

write_log() {
    init_logs_dir
    local action="$1" result="$2" warnings="$3" key="$4" email="$5" trust="$6"
    local ts; ts="$(date -u +"%Y%m%dT%H%M%SZ")"
    local file="${LOG_DIR}/${ts}-${action}.json"

    local git_actor
    git_actor="$(git config user.name) <$(git config user.email)>"
    local gpg_actor
    gpg_actor="$(gpg --list-secret-keys --keyid-format=long 2>/dev/null \
        | grep '^uid' | head -n1 | sed 's/^.*] //')"

    cat > "${file}" <<EOF
{
  "timestamp": "${ts}",
  "version": "${VERSION}",
  "action": "${action}",
  "actor_git": "${git_actor}",
  "actor_gpg": "${gpg_actor}",
  "result": "${result}",
  "warnings": "${warnings}",
  "key_fingerprint": "${key}",
  "email": "${email}",
  "trust": "${trust}"
}
EOF

    git add "${file}" >/dev/null 2>&1 || true
}

# ------------------------------------------------------------------------------
# Generic helpers
# ------------------------------------------------------------------------------

msg(){ echo -e "$*"; }
err(){ echo -e "ERROR: $*" >&2; }

require_repo(){
    git rev-parse --is-inside-work-tree >/dev/null 2>&1 \
        || { err "Run inside a Git repository"; return 1; }
}

check_trust(){
    key="$1"

    # Extract trust letter from pub record in --with-colons output
    trust=$(gpg --list-keys --with-colons "$key" 2>/dev/null | awk -F: '/^pub/ {print $2; exit}')

    # Trust levels (for reference):
    #   - unknown: e
    #   - none:    n
    #   - marginal: m
    #   - full:     f
    #   - ultimate: u
    #
    # We require: f or u

    if [ -z "$trust" ]; then
        error "No trust record found for key '$key'. Is it imported?"
        exit 1
    fi

    case "$trust" in
        f|u)
            # Key is fully trusted or ultimately trusted → OK
            return 0
            ;;
        *)
            echo "ERROR: GPG key '$key' is NOT trusted enough (trust level: '$trust')."
            echo
            echo "To trust this key, run:"
            echo "    gpg --edit-key \"$key\""
            echo "    trust"
            echo "    (select 4 = full trust)"
            echo "    quit"
            echo
            echo "Then re-run the command:"
            echo "    gcm add-users"
            echo
            exit 1
            ;;
    esac
}

fingerprint_for_key(){
    gpg --list-keys --with-colons "$1" 2>/dev/null | awk -F: '/^fpr/ {print $10; exit}'
}

email_for_key(){
    gpg --list-keys "$1" 2>/dev/null | grep uid | head -1 | sed 's/^.*] //'
}

print_help() {
    cat <<EOF
${SCRIPT_NAME} v${VERSION}

Usage:
  ${SCRIPT_NAME} <command> [options]

Commands:
  setup           Initialise git-crypt and write .gitattributes rules (clean repo only)
  add-users       Add one or more GPG users as git-crypt collaborators
  rotate-user     Rotate a user's GPG key (revoke old, add new)
  revoke-user     Revoke a GPG user from git-crypt
  list-users      List current git-crypt collaborators
  nuclear-rotate  Regenerate the git-crypt encryption key (dangerous)
  unencrypt       Remove git-crypt rules for future commits
  doctor          Run basic diagnostics
  backup          Backup .git-crypt and .gitattributes
  restore         Restore latest backup of .git-crypt and .gitattributes
  version         Show script version
  help            Show this help text

Examples:
  ${SCRIPT_NAME} setup
  ${SCRIPT_NAME} add-users
  ${SCRIPT_NAME} list-users
  ${SCRIPT_NAME} doctor
EOF
}

# ------------------------------------------------------------------------------
# Setup (clean repo only)
# ------------------------------------------------------------------------------

setup(){
    require_repo || return 1

    # Enforce: setup only on a clean repo (no staged or unstaged changes)
    if [[ -n "$(git status --porcelain)" ]]; then
        err "setup must be run on a clean repository (no staged or unstaged changes)."
        err "Please commit or stash your changes and try again."
        return 1
    fi

    # If git-crypt has never been initialised in this repo, do it now.
    # We just check for the .git-crypt directory, which 'git-crypt init' creates.
    if [[ ! -d ".git-crypt" ]]; then
        echo "[INFO] Initialising git-crypt…"
        git-crypt init
    fi

    # Ensure .gitattributes contains the standard git-crypt block
    if ! grep -q "git-crypt setup (auto-generated)" .gitattributes 2>/dev/null; then
        cat <<EOF >> .gitattributes

# git-crypt setup (auto-generated)
* filter=git-crypt diff=git-crypt

# Explicit plaintext-only
.gitattributes !filter !diff

# Explicit plaintext-only
README.md !filter !diff
*.md !filter !diff
docs/** !filter !diff
.github/** !filter !diff
.gitignore !filter !diff

# Audit logs encrypted:
${LOG_DIR}/** filter=git-crypt diff=git-crypt
EOF
        echo "[OK] Wrote git-crypt .gitattributes rules."
    else
        echo "[OK] .gitattributes already contains git-crypt rules."
    fi

    # Initialise logs dir and record a setup log
    init_logs_dir
    write_log "setup" "success" "" "" "" ""
    echo "[OK] Encryption rules applied and setup logged."

    # Auto-commit everything we changed so we end clean again
    git add .gitattributes .git-crypt "${LOG_DIR}" 2>/dev/null || true
    if ! git diff --cached --quiet 2>/dev/null; then
        git commit -m "Initial git-crypt setup"
        echo "[OK] Committed git-crypt setup and logs."
    else
        echo "[INFO] No changes to commit."
    fi
}

# ------------------------------------------------------------------------------
# Add / rotate / revoke users (auto-commit git-crypt metadata)
# ------------------------------------------------------------------------------

add_users(){
    require_repo || return 1
    init_logs_dir

    read -r -p "How many users? " count
    for ((i=0; i<count; i++)); do
        read -r -p "GPG key identifier (email, fingerprint, or key ID) for user $((i+1)): " key

        check_trust "${key}"

        local fp
        local email
        local trust

        fp="$(fingerprint_for_key "${key}")"
        email="$(email_for_key "${key}")"
        trust="$(gpg --list-keys --with-colons "$key" 2>/dev/null | awk -F: '/^pub/ {print $2}')"

        if ! git-crypt add-gpg-user "${key}"; then
            err "git-crypt add-gpg-user failed for '${key}'."
            err "Make sure the repo was initialised with 'git-crypt init' or '${SCRIPT_NAME} setup' and your GPG key is imported."
            return 1
        fi

        write_log "add-user" "success" "" "$fp" "$email" "$trust"

        if [[ -n "${email}" ]]; then
            msg "[OK] Added GPG user: ${email} (${fp})"
        else
            msg "[OK] Added GPG user: ${key} (${fp})"
        fi
    done

    # Auto-commit git-crypt metadata changes + any attribute changes + logs
    git add .git-crypt .gitattributes "${LOG_DIR}" 2>/dev/null || true
    if ! git diff --cached --quiet 2>/dev/null; then
        git commit -m "git-crypt collaborator update"
        msg "[OK] Committed git-crypt metadata changes."
    else
        msg "[INFO] No git-crypt metadata changes to commit."
    fi
}

rotate_user(){
    require_repo || return 1
    init_logs_dir

    read -r -p "How many users do you want to rotate? " count

    for ((i=0; i<count; i++)); do
        echo "== Rotation $((i+1)) of ${count} =="

        read -r -p "GPG key identifier (email, fingerprint, or key ID) to rotate: " old

        local fp email trust
        fp="$(fingerprint_for_key "${old}")"
        email="$(email_for_key "${old}")"
        trust="$(gpg --list-keys --with-colons "$old" 2>/dev/null | awk -F: '/^pub/ {print $2}')"

        if ! git-crypt revoke-gpg-user "${old}"; then
            err "git-crypt revoke-gpg-user failed for '${old}'."
            return 1
        fi
        write_log "rotate-user" "revoked" "" "$fp" "$email" "$trust"

        read -r -p "New GPG key identifier (email, fingerprint, or key ID): " new
        check_trust "${new}"

        local fp2 email2 trust2
        fp2="$(fingerprint_for_key "${new}")"
        email2="$(email_for_key "${new}")"
        trust2="$(gpg --list-keys --with-colons "$new" 2>/dev/null | awk -F: '/^pub/ {print $2}')"

        if ! git-crypt add-gpg-user "${new}"; then
            err "git-crypt add-gpg-user failed for '${new}'."
            err "Make sure the repository is initialised and your GPG key is imported."
            return 1
        fi

        write_log "rotate-user" "updated" "" "$fp2" "$email2" "$trust2"

        msg "[OK] Rotation $((i+1)) complete."
    done

    # Auto-commit git-crypt metadata changes + any attribute changes + logs
    git add .git-crypt .gitattributes "${LOG_DIR}" 2>/dev/null || true
    if ! git diff --cached --quiet 2>/dev/null; then
        git commit -m "git-crypt collaborator rotation"
        msg "[OK] Committed git-crypt metadata changes."
    else
        msg "[INFO] No git-crypt metadata changes to commit."
    fi
}

revoke_user(){
    require_repo || return 1
    init_logs_dir

    read -r -p "How many users do you want to revoke? " count

    for ((i=0; i<count; i++)); do
        echo "== Revocation $((i+1)) of ${count} =="

        read -r -p "GPG key identifier (email, fingerprint, or key ID) to revoke: " key

        local fp email trust
        fp="$(fingerprint_for_key "${key}")"
        email="$(email_for_key "${key}")"
        trust="$(gpg --list-keys --with-colons "$key" 2>/dev/null | awk -F: '/^pub/ {print $2}')"

        if ! git-crypt revoke-gpg-user "${key}"; then
            err "git-crypt revoke-gpg-user failed for '${key}'."
            return 1
        fi
        write_log "revoke-user" "success" "" "$fp" "$email" "$trust"

        msg "[OK] Revoked GPG user ${key}."
    done

    # Auto-commit git-crypt metadata changes + any attribute changes + logs
    git add .git-crypt .gitattributes "${LOG_DIR}" 2>/dev/null || true
    if ! git diff --cached --quiet 2>/dev/null; then
        git commit -m "git-crypt collaborator revoke"
        msg "[OK] Committed git-crypt metadata changes."
    else
        msg "[INFO] No git-crypt metadata changes to commit."
    fi
}

# ------------------------------------------------------------------------------
# List current collaborators
# ------------------------------------------------------------------------------

list_users() {
    require_repo || return 1

    if [[ ! -d ".git-crypt/keys" ]]; then
        echo "[INFO] No git-crypt collaborators found (no .git-crypt/keys directory)."
        return 0
    fi

    echo "Current git-crypt collaborators:"
    # Find all *.gpg under .git-crypt/keys, sort them for stable output
    # Filenames are of the form: .git-crypt/keys/default/0/<FINGERPRINT>.gpg
    local any=false
    while IFS= read -r -d '' f; do
        any=true
        local base fp uid
        base="${f##*/}"          # e.g. 117A6C729AA3...F941ECDB9735D048.gpg
        fp="${base%.gpg}"        # strip .gpg
        # Try to resolve to a local GPG uid (may fail if we don't have that pubkey locally)
        uid="$(gpg --list-keys "${fp}" 2>/dev/null | grep '^uid' | head -1 | sed 's/^.*] //')"
        if [[ -n "${uid}" ]]; then
            echo "  - ${fp}  (${uid})"
        else
            echo "  - ${fp}  (no local GPG uid)"
        fi
    done < <(find .git-crypt/keys -type f -name '*.gpg' -print0 2>/dev/null | sort -z)

    if [[ "${any}" == false ]]; then
        echo "  (none)"
    fi
}

# ------------------------------------------------------------------------------
# Nuclear rotation
# ------------------------------------------------------------------------------

nuclear_rotate(){
    require_repo || return 1
    init_logs_dir

    msg "⚠ Full encryption key reset!"
    read -r -p "Are you absolutely sure? (yes/no): " c
    [[ "$c" == "yes" ]] || { err "Aborted"; return 1; }

    git-crypt init
    write_log "nuclear-rotate" "success" "" "" "" ""
    msg "[OK] New encryption key generated."
    msg "Re-add users, then run: git add --renormalize . && git commit && git push"
}

# ------------------------------------------------------------------------------
# Remove encryption going forward (auto-commit .gitattributes)
# ------------------------------------------------------------------------------

unencrypt(){
    require_repo || return 1

    if [[ ! -f .gitattributes ]]; then
        msg "[INFO] .gitattributes not found; nothing to remove."
    else
        "${SED_CMD[@]}" '/git-crypt setup (auto-generated)/,+15d' .gitattributes || true

        git add .gitattributes
        if ! git diff --cached --quiet -- .gitattributes 2>/dev/null; then
            git commit -m "Remove git-crypt encryption rules" -- .gitattributes
            msg "[OK] Committed removal of git-crypt rules."
        else
            msg "[INFO] No changes to .gitattributes to commit."
        fi
    fi

    write_log "unencrypt" "success" "" "" "" ""
    msg "[OK] Encryption removed for future commits."
}

# ------------------------------------------------------------------------------
# Doctor (simple diagnostics, no flags)
# ------------------------------------------------------------------------------

doctor(){
    require_repo || return 1
    init_logs_dir

    local ok=true
    local status_output
    local status_exit

    echo "== git-crypt doctor =="

    status_output="$(git-crypt status 2>&1 || true)"
    status_exit=$?

    if echo "${status_output}" | grep -qi "not initialized"; then
        echo "[FAIL] git-crypt is not initialised in this repository."
        ok=false
    else
        echo "[OK] git-crypt appears to be initialised."
        if [[ ${status_exit} -ne 0 ]]; then
            echo "[WARN] git-crypt status reported issues:"
            echo
            echo "${status_output}"
            echo
            echo "Hint: run 'git-crypt status -f' and then commit to re-encrypt any affected files."
        fi
    fi

    # Simple .gitattributes presence + block check
    if [[ -f .gitattributes ]]; then
        if grep -q "git-crypt setup (auto-generated)" .gitattributes 2>/dev/null; then
            echo "[OK] .gitattributes contains git-crypt rules."
        else
            echo "[WARN] .gitattributes exists but does not contain the auto-generated git-crypt block."
        fi
    else
        echo "[WARN] .gitattributes file is missing."
    fi

    local result
    if [[ "${ok}" == true && ${status_exit} -eq 0 ]]; then
        result="success"
    else
        result="fail"
    fi

    write_log "doctor" "${result}" "" "" "" ""

    if [[ "${ok}" == true && ${status_exit} -eq 0 ]]; then
        echo
        echo "Repository looks healthy."
        return 0
    else
        echo
        echo "Repository has issues. See messages above."
        return 1
    fi
}

# ------------------------------------------------------------------------------
# Backup / Restore
# ------------------------------------------------------------------------------

backup_config(){
    require_repo || return 1
    init_logs_dir

    local repo ts backup
    repo=$(git rev-parse --show-toplevel)
    ts="$(date +%Y%m%d-%H%M%S)"
    backup="${repo}/${BACKUP_DIR_BASE}/${ts}"

    mkdir -p "${backup}"
    cp -a "${repo}/.git-crypt" "${backup}/" 2>/dev/null || true
    cp "${repo}/.gitattributes" "${backup}/" 2>/dev/null || true

    write_log "backup" "success" "" "" "" ""
    msg "[OK] Backup created: ${backup}"
}

restore_config(){
    require_repo || return 1
    init_logs_dir

    local repo latest
    repo=$(git rev-parse --show-toplevel)
    latest=$(find "${repo}/${BACKUP_DIR_BASE}" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | sort | tail -1)

    [[ -z "$latest" ]] && { err "No backups available"; return 1; }

    cp -a "${latest}/.git-crypt" "${repo}/" 2>/dev/null || true
    cp "${latest}/.gitattributes" "${repo}/" 2>/dev/null || true

    write_log "restore" "success" "" "" "" ""
    msg "[OK] Restored from: ${latest}"
}

# ------------------------------------------------------------------------------
# CLI
# ------------------------------------------------------------------------------

if [[ $# -eq 0 ]]; then
    print_help
    exit 1
fi

cmd="$1"; shift || true
case "$cmd" in
    version|--version)
        echo "${SCRIPT_NAME} v${VERSION}"
        exit 0
        ;;
    help|-h|--help)
        print_help
        exit 0
        ;;
    setup)           setup "$@" ;;
    add-users)       add_users "$@" ;;
    rotate-user)     rotate_user "$@" ;;
    revoke-user)     revoke_user "$@" ;;
    list-users)      list_users "$@" ;;
    nuclear-rotate)  nuclear_rotate "$@" ;;
    unencrypt)       unencrypt "$@" ;;
    doctor)          doctor "$@" ;;
    backup)          backup_config "$@" ;;
    restore)         restore_config "$@" ;;
    *)
        err "Unknown command: $cmd"
        echo
        print_help
        exit 1
        ;;
esac
